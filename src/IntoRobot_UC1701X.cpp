/*
 ******************************************************************************

 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation, either
 version 3 of the License, or (at your option) any later version.

 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, see <http://www.gnu.org/licenses/>.

 Adapted for IntoRobot by Robin, Sept 19, 2015
 ********************************************************************
 */

#include "IntoRobot_UC1701X.h"

// the memory buffer for the LCD

static uint8_t buffer[LCD_HEIGHT * LCD_WIDTH / 8] = {

    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xA0,0xA0,0xA0,0xA0,0x80,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,
    0x40,0x40,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x80,0x00,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,0xA0,
    0xA0,0x80,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x80,0x00,0xD0,0xD0,0xD0,0xD0,0xD0,0x00,0xC0,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x40,0x40,0x40,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x70,0x07,0xF8,0xFF,0xFF,0xFF,0xFF,0x1F,0x71,0xCE,0xF8,
    0xFA,0xFA,0xF8,0xF4,0xF4,0xF8,0xFA,0xFA,0xFA,0xF8,0xF0,0x00,0xF8,0xFA,0xFE,0xFF,
    0xFF,0xFF,0xFF,0xFB,0xFA,0x3B,0xD0,0xE8,0xF4,0xF4,0xF8,0xFA,0xFA,0xFA,0xFA,0xF0,
    0xF4,0xE8,0x10,0x3C,0xE1,0xFE,0xFF,0xFF,0xFF,0xBF,0xA7,0xBF,0xBF,0xCF,0xFF,0xFF,
    0xFF,0xFF,0xFF,0x00,0xB3,0xD0,0xE8,0xF4,0xF4,0xFA,0xFA,0xFA,0xFA,0xFA,0xF4,0xF4,
    0xE8,0x10,0x0E,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xF9,0xFA,0xFA,0xFA,0xF8,0xF4,0xC0,
    0xB0,0xD0,0xE8,0xF4,0xF4,0xFA,0xFA,0xFA,0xFA,0xFA,0xF4,0xF4,0xE8,0x00,0xF8,0xFA,
    0xFE,0xFF,0xFF,0xFF,0xFF,0xFB,0xFA,0x3B,0x40,0x10,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0xE0,0x0E,0xF0,0xFF,0xFF,0xFF,0xFF,0x1F,0x61,0x86,0xFC,0xFF,0xFF,
    0xFF,0x7F,0x87,0x1D,0xF2,0xFE,0xFF,0xFF,0xFF,0x1F,0xE1,0x06,0xFC,0xFF,0xFF,0xFF,
    0xFF,0xEF,0xEA,0x0E,0xB0,0xFF,0xFF,0xFF,0xFF,0xFF,0xEA,0xEE,0xFA,0xFF,0xFF,0x7F,
    0xBF,0x0F,0xC0,0xFE,0xFF,0xFF,0xFF,0x7F,0xAF,0x6F,0xBF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xEB,0xBD,0xC6,0x78,0xFF,0xFF,0xFF,0xFF,0xEF,0xEA,0xEB,0xFC,0xFF,0xFF,0x7F,0xBF,
    0x07,0xE0,0xFF,0xFF,0xFF,0xFF,0xFF,0xEB,0xEE,0xFA,0xFF,0xFF,0xFF,0xBF,0x8F,0x78,
    0xFF,0xFF,0xFF,0xFF,0xEF,0xEA,0xEB,0xFC,0xFF,0xFF,0x7F,0xBF,0xE7,0x00,0xFC,0xFF,
    0xFF,0xFF,0xFF,0xEF,0xEA,0x02,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x01,0x05,0x05,0x05,0x05,0x01,0x00,0x00,0x01,0x05,0x05,0x05,
    0x05,0x00,0x01,0x00,0x05,0x05,0x05,0x05,0x01,0x00,0x01,0x00,0x01,0x05,0x05,0x05,
    0x05,0x05,0x05,0x00,0x01,0x02,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x02,0x01,
    0x01,0x00,0x05,0x05,0x05,0x05,0x05,0x00,0x01,0x00,0x01,0x00,0x05,0x05,0x05,0x05,
    0x05,0x05,0x00,0x01,0x02,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x01,0x02,0x01,0x01,
    0x00,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x02,0x00,0x00,0x00,0x01,
    0x02,0x05,0x05,0x05,0x05,0x05,0x05,0x05,0x01,0x02,0x01,0x00,0x00,0x00,0x01,0x05,
    0x05,0x05,0x05,0x05,0x05,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00

};



// the most basic function, set a single pixel
void IntoRobot_UC1701X::drawPixel(int16_t x, int16_t y, uint16_t color)
{
    if ((x < 0) || (x >= width()) || (y < 0) || (y >= height()))
        return;

    // check rotation, move pixel around if necessary
    switch (getRotation())
    {
        case 1:
            swap(x, y);
            x = WIDTH - x - 1;
            break;
        case 2:
            x = WIDTH - x - 1;
            y = HEIGHT - y - 1;
            break;
        case 3:
            swap(x, y);
            y = HEIGHT - y - 1;
            break;
    }

    // x is which column
    if (color == WHITE)
        buffer[x+ (y/8)*LCD_WIDTH] |= (1 << (y&7));
    else
        buffer[x+ (y/8)*LCD_WIDTH] &= ~(1 << (y&7));
}

// constructor for software SPI - we indicate DataCommand, ChipSelect, Reset
IntoRobot_UC1701X::IntoRobot_UC1701X(int8_t CS,int8_t RST,int8_t DC,int8_t SID, int8_t SCLK) : Adafruit_GFX(LCD_WIDTH, LCD_HEIGHT)
{
    cs = CS;
    rst = RST;
    dc = DC;
    sclk = SCLK;
    sid = SID;
    hwSPI = false;
}

// constructor for hardware SPI - we indicate DataCommand, ChipSelect, Reset
IntoRobot_UC1701X::IntoRobot_UC1701X(int8_t CS, int8_t RST, int8_t DC) : Adafruit_GFX(LCD_WIDTH, LCD_HEIGHT)
{
    dc = DC;
    rst = RST;
    cs = CS;
    hwSPI = true;
}

void IntoRobot_UC1701X::begin(void)
{
    // set pin directions
    pinMode(dc, OUTPUT);
    pinMode(cs, OUTPUT);

    if (!hwSPI)
    {
        // set pins for software-SPI
        pinMode(sid, OUTPUT);
        pinMode(sclk, OUTPUT);
        digitalWrite(sclk, LOW);
    }
    else // hardware spi
    {
        digitalWrite(cs, HIGH);
        SPI.setBitOrder(MSBFIRST);
        SPI.setClockDivider(SPI_CLOCK_DIV8);	// 72MHz / 8 = 9Mhz
        //SPI.setDataMode(0);
        SPI.begin();
    }

    // Setup reset pin direction (used by both SPI and I2C)
    pinMode(rst, OUTPUT);
    digitalWrite(rst, HIGH);
    // VDD (3.3V) goes high at start, lets just chill for a ms
    delay(1);
    // bring reset low
    digitalWrite(rst, LOW);
    // wait 10ms
    delay(10);
    // bring out of reset
    digitalWrite(rst, HIGH);
    // turn on VCC (9V?)
    uc1701x_command(0xE2);  //System Reset
    uc1701x_command(0x40); // Set display start line to 0
    uc1701x_command(0xA0); //Set SEG Direction
    uc1701x_command(0xC8); //Set COM Direction
    uc1701x_command(0xA2); //Set Bias = 1/9
    uc1701x_command(0x2C);  //Boost ON
    uc1701x_command(0x2E); //Voltage Regular On
    uc1701x_command(0x2F); //Voltage Follower On
    uc1701x_command(0xF8); //Set booster ratio to
    uc1701x_command(0x00); // x
    uc1701x_command(0x23); //Set Resistor Ratio = 3
    uc1701x_command(0x81);
    uc1701x_command(0x28); //Set Electronic Volume = 40
    uc1701x_command(0xAC);//Set Static indicator off
    uc1701x_command(0x00);
    uc1701x_command(0XA6); // Disable inverse
    uc1701x_command(0xAF); //Set Display Enable
    delay(100);
    uc1701x_command(0xA5); //display all points
    delay(200);
    uc1701x_command(0xA4); //normal display

    clearScreen();

    display();

    delay(3000);

    clearScreen();

}


void IntoRobot_UC1701X::clearScreen(void)
{
    fillScreen(0x00);
}


void IntoRobot_UC1701X::fullScreen(void)
{
    fillScreen(0xff);
}


void IntoRobot_UC1701X::fillScreen(unsigned char dat)
{
    for (unsigned short j = 0; j < 8; j++)
    {
        set_uc1701xCursor(0, j);
        for (unsigned short i = 0; i < 132 ; i++)
        {
            uc1701x_data(dat);
        }
    }
    set_uc1701xCursor(0, 0);
}


void IntoRobot_UC1701X::set_uc1701xCursor(unsigned char column, unsigned char page)
{
    uc1701x_command(0xb0+page);
    uc1701x_command(0x10 | ((column >> 4) & 0x0f));
    uc1701x_command(column & 0x0F);
}


void IntoRobot_UC1701X::uc1701x_command(uint8_t c)
{
    digitalWrite(cs, HIGH);
    digitalWrite(dc, LOW);
    digitalWrite(cs, LOW);
    fastSPIwrite(c);
    digitalWrite(cs, HIGH);
}

void IntoRobot_UC1701X::uc1701x_data(uint8_t c)
{
    digitalWrite(cs, HIGH);
    digitalWrite(dc, HIGH);
    digitalWrite(cs, LOW);
    fastSPIwrite(c);
    digitalWrite(cs, HIGH);
}

inline void IntoRobot_UC1701X::fastSPIwrite(uint8_t d)
{
    if(hwSPI)
    {
        (void)SPI.transfer(d);
    }
    else
    {
        shiftOut(sid, sclk, MSBFIRST, d); // uc1701x specs show MSB out first
    }
}


//粗调对比度 0x20-0x2f
void IntoRobot_UC1701X::coarseContrast(uint8_t contrast)
{
    uint8_t contrastValue;
    if(contrast < 0x20) contrastValue = 0x20;
    else if(contrast > 0x2f) contrastValue = 0x2f;
    else contrastValue = contrast;
    uc1701x_command(contrastValue);
}

//细调对比度 0-63
void IntoRobot_UC1701X::fineTuneContrast(uint8_t contrast)
{
    uint8_t contrastValue;
    if(contrast < 0) contrastValue = 0;
    else if(contrast > 63) contrastValue = 63;
    else contrastValue = contrast;
    uc1701x_command(0x81);
    uc1701x_command(contrastValue);
}


void IntoRobot_UC1701X::display(void)
{
    for (unsigned char page = 0; page < 8; page++)
    {
        uc1701x_command(0xb0+page);
        uc1701x_command(0x10);
        uc1701x_command(0x00);

        digitalWrite(cs, HIGH);
        digitalWrite(dc, HIGH);
        digitalWrite(cs, LOW);

        for(unsigned char column = 0; column< 128 ; column++)
        {
            fastSPIwrite(buffer[page*128 + column]);
        }

        digitalWrite(cs, HIGH);
    }

}

// clear everything
void IntoRobot_UC1701X::clearDisplay(void)
{
    memset(buffer, 0, (LCD_WIDTH*LCD_HEIGHT/8));
}




void IntoRobot_UC1701X::drawFastHLine(int16_t x, int16_t y, int16_t w, uint16_t color) {
    boolean bSwap = false;
    switch(rotation) {
        case 0:
            // 0 degree rotation, do nothing
            break;
        case 1:
            // 90 degree rotation, swap x & y for rotation, then invert x
            bSwap = true;
            swap(x, y);
            x = WIDTH - x - 1;
            break;
        case 2:
            // 180 degree rotation, invert x and y - then shift y around for height.
            x = WIDTH - x - 1;
            y = HEIGHT - y - 1;
            x -= (w-1);
            break;
        case 3:
            // 270 degree rotation, swap x & y for rotation, then invert y  and adjust y for w (not to become h)
            bSwap = true;
            swap(x, y);
            y = HEIGHT - y - 1;
            y -= (w-1);
            break;
    }

    if(bSwap) {
        drawFastVLineInternal(x, y, w, color);
    } else {
        drawFastHLineInternal(x, y, w, color);
    }
}

void IntoRobot_UC1701X::drawFastHLineInternal(int16_t x, int16_t y, int16_t w, uint16_t color) {
    // Do bounds/limit checks
    if(y < 0 || y >= HEIGHT) { return; }

    // make sure we don't try to draw below 0
    if(x < 0) {
        w += x;
        x = 0;
    }

    // make sure we don't go off the edge of the display
    if( (x + w) > WIDTH) {
        w = (HEIGHT- x);
    }

    // if our width is now negative, punt
    if(w <= 0) { return; }

    // set up the pointer for  movement through the buffer
    register uint8_t *pBuf = buffer;
    // adjust the buffer pointer for the current row
    pBuf += ((y/8) * LCD_WIDTH);
    // and offset x columns in
    pBuf += x;

    register uint8_t mask = 1 << (y&7);

    if(color == WHITE) {
        while(w--) { *pBuf++ |= mask; }
    } else {
        mask = ~mask;
        while(w--) { *pBuf++ &= mask; }
    }
}

void IntoRobot_UC1701X::drawFastVLine(int16_t x, int16_t y, int16_t h, uint16_t color) {
    bool bSwap = false;
    switch(rotation) {
        case 0:
            break;
        case 1:
            // 90 degree rotation, swap x & y for rotation, then invert x and adjust x for h (now to become w)
            bSwap = true;
            swap(x, y);
            x = WIDTH - x - 1;
            x -= (h-1);
            break;
        case 2:
            // 180 degree rotation, invert x and y - then shift y around for height.
            x = WIDTH - x - 1;
            y = HEIGHT - y - 1;
            y -= (h-1);
            break;
        case 3:
            // 270 degree rotation, swap x & y for rotation, then invert y
            bSwap = true;
            swap(x, y);
            y = HEIGHT - y - 1;
            break;
    }

    if(bSwap) {
        drawFastHLineInternal(x, y, h, color);
    } else {
        drawFastVLineInternal(x, y, h, color);
    }
}


void IntoRobot_UC1701X::drawFastVLineInternal(int16_t x, int16_t __y, int16_t __h, uint16_t color) {

    // do nothing if we're off the left or right side of the screen
    if(x < 0 || x >= WIDTH) { return; }

    // make sure we don't try to draw below 0
    if(__y < 0) {
        // __y is negative, this will subtract enough from __h to account for __y being 0
        __h += __y;
        __y = 0;

    }

    // make sure we don't go past the height of the display
    if( (__y + __h) > HEIGHT) {
        __h = (HEIGHT - __y);
    }

    // if our height is now negative, punt
    if(__h <= 0) {
        return;
    }

    // this display doesn't need ints for coordinates, use local byte registers for faster juggling
    register uint8_t y = __y;
    register uint8_t h = __h;


    // set up the pointer for fast movement through the buffer
    register uint8_t *pBuf = buffer;
    // adjust the buffer pointer for the current row
    pBuf += ((y/8) * LCD_WIDTH);
    // and offset x columns in
    pBuf += x;

    // do the first partial byte, if necessary - this requires some masking
    register uint8_t mod = (y&7);
    if(mod) {
        // mask off the high n bits we want to set
        mod = 8-mod;

        // note - lookup table results in a nearly 10% performance improvement in fill* functions
        // register uint8_t mask = ~(0xFF >> (mod));
        static uint8_t premask[8] = {0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE };
        register uint8_t mask = premask[mod];

        // adjust the mask if we're not going to reach the end of this byte
        if( h < mod) {
            mask &= (0XFF >> (mod-h));
        }

        if(color == WHITE) {
            *pBuf |= mask;
        } else {
            *pBuf &= ~mask;
        }

        // fast exit if we're done here!
        if(h<mod) { return; }

        h -= mod;

        pBuf += LCD_WIDTH;
    }


    // write solid bytes while we can - effectively doing 8 rows at a time
    if(h >= 8) {
        // store a local value to work with
        register uint8_t val = (color == WHITE) ? 255 : 0;

        do  {
            // write our value in
            *pBuf = val;

            // adjust the buffer forward 8 rows worth of data
            pBuf += LCD_WIDTH;

            // adjust h & y (there's got to be a faster way for me to do this, but this should still help a fair bit for now)
            h -= 8;
        } while(h >= 8);
    }

    // now do the final partial byte, if necessary
    if(h) {
        mod = h & 7;
        // this time we want to mask the low bits of the byte, vs the high bits we did above
        // register uint8_t mask = (1 << mod) - 1;
        // note - lookup table results in a nearly 10% performance improvement in fill* functions
        static uint8_t postmask[8] = {0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F };
        register uint8_t mask = postmask[mod];
        if(color == WHITE) {
            *pBuf |= mask;
        } else {
            *pBuf &= ~mask;
        }
    }
}
